
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module daedalus(

	//////////// CLOCK //////////
	CLOCK_125_p,
	CLOCK_50_B5B,
	CLOCK_50_B6A,
	CLOCK_50_B7A,
	CLOCK_50_B8A,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	CPU_RESET_n,
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,

	//////////// HDMI-TX //////////
	HDMI_TX_CLK,
	HDMI_TX_D,
	HDMI_TX_DE,
	HDMI_TX_HS,
	HDMI_TX_INT,
	HDMI_TX_VS,

	//////////// ADC SPI //////////
	ADC_CONVST,
	ADC_SCK,
	ADC_SDI,
	ADC_SDO,

	//////////// Audio //////////
	AUD_ADCDAT,
	AUD_ADCLRCK,
	AUD_BCLK,
	AUD_DACDAT,
	AUD_DACLRCK,
	AUD_XCK,

	//////////// I2C for Audio/HDMI-TX/Si5338/HSMC //////////
	I2C_SCL,
	I2C_SDA,

	//////////// SDCARD //////////
	SD_CLK,
	SD_CMD,
	SD_DAT,

	//////////// Uart to USB //////////
	UART_RX,
	UART_TX,

	//////////// SRAM //////////
	SRAM_A,
	SRAM_CE_n,
	SRAM_D,
	SRAM_LB_n,
	SRAM_OE_n,
	SRAM_UB_n,
	SRAM_WE_n,

`ifdef ENABLE_LPDDR2
	//////////// LPDDR2 //////////
	DDR2LP_CA,
	DDR2LP_CK_n,
	DDR2LP_CK_p,
	DDR2LP_CKE,
	DDR2LP_CS_n,
	DDR2LP_DM,
	DDR2LP_DQ,
	DDR2LP_DQS_n,
	DDR2LP_DQS_p,
	DDR2LP_OCT_RZQ
`endif	
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_125_p;
input 		          		CLOCK_50_B5B;
input 		          		CLOCK_50_B6A;
input 		          		CLOCK_50_B7A;
input 		          		CLOCK_50_B8A;

//////////// LED //////////
output		     [7:0]		LEDG;
output		     [9:0]		LEDR;

//////////// KEY //////////
input 		          		CPU_RESET_n;
input 		     [3:0]		KEY;

//////////// SW //////////
input 		     [9:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;

//////////// HDMI-TX //////////
output		          		HDMI_TX_CLK;
output		    [23:0]		HDMI_TX_D;
output		          		HDMI_TX_DE;
output		          		HDMI_TX_HS;
input 		          		HDMI_TX_INT;
output		          		HDMI_TX_VS;

//////////// ADC SPI //////////
output		          		ADC_CONVST;
output		          		ADC_SCK;
output		          		ADC_SDI;
input 		          		ADC_SDO;

//////////// Audio //////////
input 		          		AUD_ADCDAT;
inout 		          		AUD_ADCLRCK;
inout 		          		AUD_BCLK;
output		          		AUD_DACDAT;
inout 		          		AUD_DACLRCK;
output		          		AUD_XCK;

//////////// I2C for Audio/HDMI-TX/Si5338/HSMC //////////
output		          		I2C_SCL;
inout 		          		I2C_SDA;

//////////// SDCARD //////////
output		          		SD_CLK;
inout 		          		SD_CMD;
inout 		     [3:0]		SD_DAT;

//////////// Uart to USB //////////
input 		          		UART_RX;
output		          		UART_TX;

//////////// SRAM //////////
output		    [17:0]		SRAM_A;
output		          		SRAM_CE_n;
inout 		    [15:0]		SRAM_D;
output		          		SRAM_LB_n;
output		          		SRAM_OE_n;
output		          		SRAM_UB_n;
output		          		SRAM_WE_n;

`ifdef ENABLE_LPDDR2
//////////// LPDDR2 //////////
output		     [9:0]		DDR2LP_CA;
output		          		DDR2LP_CK_n;
output		          		DDR2LP_CK_p;
output		     [1:0]		DDR2LP_CKE;
output		     [1:0]		DDR2LP_CS_n;
output		     [3:0]		DDR2LP_DM;
inout 		    [31:0]		DDR2LP_DQ;
inout 		     [3:0]		DDR2LP_DQS_n;
inout 		     [3:0]		DDR2LP_DQS_p;
input 		          		DDR2LP_OCT_RZQ;
`endif

//=======================================================
//  REG/WIRE declarations
//=======================================================

wire clock, resetn;
wire [15:0] display;
wire display_enable;

wire load_mar, load_mdr;
wire [15:0] reg_d, reg_q, mar_q, mdr_q;

//=======================================================
//  Structural coding
//=======================================================

assign clock = CLOCK_50_B5B;
assign resetn = CPU_RESET_n;
assign display_enable = 1'b1;

// Hex display
hex_driver hex0 (.enable(display_enable), .in(display[3:0]), .out(HEX0));
hex_driver hex1 (.enable(display_enable), .in(display[7:4]), .out(HEX1));
hex_driver hex2 (.enable(display_enable), .in(display[11:8]), .out(HEX2));
hex_driver hex3 (.enable(display_enable), .in(display[15:12]), .out(HEX3));

// Registers
reg16 mar (.clock, .resetn, .load(load_mar), .d(reg_d), .q(mar_q));
reg16 mdr (.clock, .resetn, .load(load_mdr), .d(reg_d), .q(mdr_q));

assign reg_q = SW[9] ? mar_q : mdr_q;
assign display = reg_q;

always_comb
begin
	if (~KEY[2])
	begin
		load_mar = 1'b0;
		load_mdr = 1'b1;
		reg_d = SRAM_D;
	end
	else
	begin
		load_mar = SW[9] & ~KEY[3];
		load_mdr = ~SW[9] & ~KEY[3];
		reg_d = SW[8] ? { SW[7:0], reg_q[7:0] } : { reg_q[15:8], SW[7:0] };
	end
end

// Drive SRAM signals

assign SRAM_CE_n = 1'b0;
assign SRAM_OE_n = 1'b0;
assign SRAM_UB_n = 1'b0;
assign SRAM_LB_n = 1'b0;
assign SRAM_WE_n = KEY[1];
assign SRAM_D = SRAM_WE_n ? 'hZ : mdr_q;

assign SRAM_A = { 2'b00, mar_q };

endmodule
